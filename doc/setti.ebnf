funcdef:          'func' id '(' [func_arg_ls] ')' [type] block
cmd_def:          'cmd' id block
block:            '{' stmt_list '}'
stmt_list:        stmt (';' stmt)*
stmt:             simple_stmt | compound_stmt
simple_stmt:      small_stmt ';'
small_stmt:       (assign_stmt | flow_stmt | cmd_stmt | inline_cmd | const_stmt | import_stmt | assert_stmt)
compound_stmt:    if_stmt | while_stmt | for_stmt | try_stmt | line_func_def | decorated | async_stmt
inline_cmd:       '$(' cmd_stmt ')'
cmd_stmt:         cmd_and_or ('&')?
cmd_and_or:       cmd_pipe (('&&' | '||') cmd_pipe)*
cmd_pipe:         cmd ('|' cmd)*

// A command is anything that not match on other rule
// on cmd only some tokens are special, the others is part
// of the command, command is not like other bnf rule
// All others tokens and rules are part of command, except:
// io_redirect, cmd_pipe, cmd_and_or, cmd_stmt, '$' and ';'
// the character scape must be used
*cmd:             cmd_word (cmd_word | *any)? (io_redirect)*

io_redirect:      INTEGER io_file
io_file:          ('<' | '<<' | '>' | '>>') filename
filename:         WORD | post_expr
line_func_def:    'func' '(' [func_arg_ls] ')' [type] block
func_arg_ls:      func_arg (',' func_arg)*
func_arg:         arg_type '=' expression
arg_type:         [type] var
for_stmt:         'for' id_list 'in' assignable_list block
while_stmt:       'while' expression block
flow_stmt:         break_stmt | continue_stmt | return_stmt
break_stmt:       'break'
continue_stmt:    'continue'
return_stmt:      'return' (assignable_list)?
assign_stmt:      id_list augassign assignable_list
const_stmt:       'const' id '=' assignable
augassign:        ('=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' |
                  '<<=' | '>>=' )
if_stm:           if expression block (else_stm)?
else_stm:         else (if_stm | block)
assignable_list:  assignable (',' assignable)*
assignable:       expression | line_func_def
expression:       or_test ['if' or_test 'else' expression]
or_test:          and_test ('or' and_test)*
and_test:         not_test ('and' not_test)*
not_test:         'not' not_test | comparison
comparison:       expr (comp_op expr)*
comp_op:          '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'
expr:             xor_expr ('|' xor_expr)*
xor_expr:         and_expr ('^' and_expr)*
and_expr:         shift_expr ('&' shift_expr)*
shift_expr:       arith_expr (('<<'|'>>') arith_expr)*
arith_expr:       term (('+'|'-') term)*
term:             factor (('*'|'/'|'%') factor)*
factor:           ('+'|'-'|'~') factor | post_expr
post_expr:        post_expr '->' post_expr | post_expr '[' subscriptls ']' | scope_expr | func_call | primary_expr
func_call:        (post_expr | pack_scope id) ( '(' param_list ')' | '(' ')')
param_list:       arg_param (',' arg_param)*
subscriptls:      subscript (',' subscript)*
subscript:        expression | [expression] ':' [expression] [sliceop]
sliceop:          ':' [expression]
arg_param:        arg_assign | expression
arg_assign:       var_id '=' expression
primary_expr:     literal | var_id | '('expression')' | inline_cmd
id_list:          var_type (',' var_type)*
var_type:         (type)? var_id
type:             [pack_scope] id
pack_scope:       (id '::')+
literal:          STRING | INTEGER | REAL | BOOL_CONST | id | var_id
cmd_word:         id | word | id '::' id
word:             WORD
BOOL_CONS:        'true' | 'false'
